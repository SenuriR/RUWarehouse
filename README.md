# RUWarehouse
[CS112 - Data Structures] Utilizes priority queues and hash tables for the creation and maintenance of a warehouse inventory database.


OVERVIEW:
Congratulations, you’ve just won the lottery and decided to use the money to start a Rutgers merch store! You have some warehouse space to store your inventory, but you are having trouble keeping track of what items you currently have in stock. Your warehouse can store up to 50 different product types, and being a new store, you will be frequently adding new products. You need a structure that can efficiently look up products and delete underperforming ones to make space for new items.

DESIGN:
--> You settle on a Hash Table like structure, where each entry of the table stores a priority queue. Due to your limited space, you are unable to simply rehash to get more space. However, you can use your priority queue structure to delete less popular items and keep the space constant.
--> Your warehouse is split into 10 sectors, each of which can hold 5 product types.
--> The last digit of the product ID determines which sector it should go into. Then when we search for it, we can immediately narrow down the search to at most 5 items rather than searching through the entire warehouse.
--> You settle on a simple metric for how well an item is doing: Popularity = Initial Demand + Total Amount Purchased + Date of Last Purchase. The initial demand is obtained from a survey prior to product release, and the date of last purchase is simply the number of days since the store opening that the item was last purchased.
--> You want to be able to delete the least popular item in a sector efficiently, so you decide to make each sector a min heap ranked by popularity.
--> Even though each sector is a min heap, it can still function as a normal list, which you can search through sequentially.


OVERVIEW OF FILES:
Product.java
--> Contains the product ID, name, stock, date of last purchase, demand, and overall popularity. The demand is simply the sum of the initial demand for the product and the number purchased.
--> Getters and setters are provided, as well as special methods to update the stock and demand by some positive or negative amount.
--> You cannot manually set the popularity, but it is automatically calculated and updated as the sum of the last purchase day and current demand.
--> DO NOT edit this file.
Sector.java
--> Contains an array of Products which forms a valid min heap based on popularities, as well as the current size of the sector (defined as the number of Products in it). 
--> On Products array we ignore index 0 just like in class. Then at any moment, the indices containing valid Products range from 1 to currentSize inclusive.
--> Contains helpful methods to add a Product to the end of the sector, set some index, delete the last Product, get the Product at some index and get the current size.
--> The Sector class alone isn’t a fully implemented min-heap. However, you’re provided a method to swap the Products at 2 indices, a method to apply the swim algorithm from class on some index, and a method to apply the sink algorithm from class on some index.
--> DO NOT edit this file.
Warehouse.java
--> Contains an array of 10 Sectors, with index i representing sector i.
--> Contains methods to fill in for every sub-problem in the assignment.
--> DO edit the empty methods in this file.
--> DO NOT edit the provided methods in this file.
--> This file will be submitted for grading.
StdIn.java
--> Use StdIn.setFile(filename) to set the current input file you want to read from.
--> You can now use StdIn.readInt() and StdIn.readString() to operate on the file as if it were standard input. These methods ignore whitespace.
StdOut.java
--> Use StdOut.setFile(filename) to set the current output file you want to write to.
--> You can now use StdOut.println() to operate on the file as if it were standard output.
Method files
--> The structure of this assignment is significantly different from previous assignments.
--> Rather than being provided with a driver, you are provided with an empty java file for each graded method.
--> DO fill in the main methods in these files.
--> Each class is expected to take 2 command line arguments, an input file and an output file.
--> Use StdIn and StdOut to read from the input file and write the solution to the output file.
--> These files will not be graded, but they are necessary for testing of your methods.
Input files
--> Each subtask has a corresponding .in file to help you test the method.
--> Feel free to write your own, as long as you adhere to the formats provided
